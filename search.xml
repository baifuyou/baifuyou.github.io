<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[尾递归实现foldRight]]></title>
      <url>http://www.scratbai.com/2016/07/31/%E5%B0%BE%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0foldRight/</url>
      <content type="html"><![CDATA[<h2 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h2><p>尾递归是指递归调用作为函数执行的最后一条语句，这样的情况下递归调用发生时，当前的栈帧就不需要了。如果语言有对尾递归做这样的优化，那么不论尾递归调用多少层，都不会有栈溢出的风险。特别注意的是，类似于下面这样的代码不是尾递归的，因为它执行的最后一条语句是 h + sum_result 而不是 sum(t) ，换句话说，这里调用 sum 时，栈帧还不能抛弃，因为栈帧中还需要保存 h 。<br>更详细的简绍请看： <a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8</a></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Int</span> = list <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="number">0</span>;</div><div class="line">  <span class="keyword">case</span> h::t =&gt; h + sum(t)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="非尾递归的实现"><a href="#非尾递归的实现" class="headerlink" title="非尾递归的实现"></a>非尾递归的实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight2</span></span>[<span class="type">E</span>, <span class="type">B</span>](l: <span class="type">List</span>[<span class="type">E</span>], b: <span class="type">B</span>)(op: (<span class="type">E</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = l <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; b</div><div class="line">  <span class="keyword">case</span> h::t =&gt; op(h, foldRight(t, b)(op))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码以一种最容易想到的方法实现了 foldRight， 但是很遗憾，它不是尾递归。::方法是常量时间完成，不涉及递归，后面不再解释。递归调用 foldRight 返回后还需要使用 h 和递归结果作为参数调用 op，栈帧中还需要保存 h 和 op，所以以上实现不是尾递归的。</p>
<h2 id="尾递归的实现"><a href="#尾递归的实现" class="headerlink" title="尾递归的实现"></a>尾递归的实现</h2><p>虽然直接实现 foldRight 的尾递归版本有困难，但是 foldLeft 却很容易用尾递归实现。那我们实现一个尾递归的foldLeft，然后翻转 list 调用 foldLeft ，以此来实现 foldRight ，这样可行吗？下面试试看。</p>
<h3 id="尾递归的-foldLeft"><a href="#尾递归的-foldLeft" class="headerlink" title="尾递归的 foldLeft"></a>尾递归的 foldLeft</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">E</span>, <span class="type">B</span>](l: <span class="type">List</span>[<span class="type">E</span>], b: <span class="type">B</span>)(op: (<span class="type">B</span>, <span class="type">E</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = l <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; b</div><div class="line">  <span class="keyword">case</span> h::t =&gt; foldLeft(t, op(b, h))(op)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上实现，最后执行的代码就是对foldLeft的递归调用，栈帧中需要保存任何信息，显然是尾递归的。</p>
<h3 id="使用-foldLeft-实现-foldRight"><a href="#使用-foldLeft-实现-foldRight" class="headerlink" title="使用 foldLeft 实现 foldRight"></a>使用 foldLeft 实现 foldRight</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">E</span>, <span class="type">B</span>](l: <span class="type">List</span>[<span class="type">E</span>], b: <span class="type">B</span>)(op: (<span class="type">E</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = l <span class="keyword">match</span> &#123;</div><div class="line"><span class="keyword">case</span> <span class="type">Nil</span> =&gt; b</div><div class="line"><span class="keyword">case</span> h::t =&gt; foldLeft(reverse(l), b)((b, e) =&gt; op(e, b))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就完了吗？当然没有，上面的实现使用了reverse函数，得尾递归实现reverse才行</p>
<h3 id="尾递归实现reverse"><a href="#尾递归实现reverse" class="headerlink" title="尾递归实现reverse"></a>尾递归实现reverse</h3><p>这里就不卖关子了，直接使用 foldLeft 来实现 reverse 就可以了。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span>[<span class="type">E</span>](l: <span class="type">List</span>[<span class="type">E</span>]): <span class="type">List</span>[<span class="type">E</span>] = l <span class="keyword">match</span> &#123;</div><div class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></div><div class="line">  <span class="keyword">case</span> h::t =&gt; l.foldLeft(<span class="type">Nil</span>:<span class="type">List</span>[<span class="type">E</span>])((b, e) =&gt; e::b)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="结果检验"><a href="#结果检验" class="headerlink" title="结果检验"></a>结果检验</h2><p>上面有了 foldRight2 和 foldRight 两个实现。我们用一个长 list 来分别调用两个函数看看是否栈溢出。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">App</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bigList</span> </span>= <span class="number">1.</span>to(<span class="number">10000</span>).toList</div><div class="line">    println(foldRight2(bigList, <span class="number">0</span>)((e, b) =&gt; e + b))</div><div class="line">    <span class="comment">//println(foldRight(bigList, 0)((e, b) =&gt; e + b))</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面使用了一个长度为10000的 list，计算所有元素的和。<br>使用 foldRight2 时发生了栈溢出，根据jvm启动参数的不同，发生栈溢出的临界值是不一样的。</p>
<p><img src="/images/尾递归实现foldRight/stackoverflow_result.png" alt="Alt text"></p>
<p>使用 foldRight 时正确输出了结果</p>
<p><img src="/images/尾递归实现foldRight/success_result.png" alt="Alt text"></p>
<p>说明这里的尾递归实现是正确的，并且Scala的做出了正确的优化。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最长递增路径-LeetCode]]></title>
      <url>http://www.scratbai.com/2016/07/09/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84-LeetCode/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 M × N 的矩阵，找出其中最长的递增序列的长度<br>递增序列的方向可以是当前元素的上下左右，但不能是对角线，也不可以跨越边界</p>
<h3 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nums = [</div><div class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</div><div class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</div><div class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>返回值是4，最长的递增序列是：1，2，6，9</p>
<h3 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nums = [</div><div class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</div><div class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>],</div><div class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>返回值是4，最长的递增序列是：2，4，5，6 或者 3，4，5，6</p>
<p>题目来源： <a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="external">Longest Increasing Path in a Matrix</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>方法很直观，依次计算每一个元素的最长递增路径长（下面简称LI），然后选取最大的值作为最终结果。</p>
<p>然后要考虑的是，如何计算每一个元素的LI。很容易想到，每个元素有2-4个相邻元素，要计算当前元素的LI，<br>先要找出值比当前元素大的相邻元素，并计算每个相邻元素的LI，然后找出最大的相邻元素LI，加上1就是当前元素的LI。如果所有相邻元素的值都不比当前元素大，则当前元素的LI为0。</p>
<p>上述就是一个递归过程，递归结束点就是值大于等于所有相邻元素的元素。</p>
<p>按照以上思路实现应该就可以输出正确答案了，但是未必能被Accepted（猜的，我没试过）。因为上述算法虽然能输出正确结果，但是每个元素都可能计算多次LI。所以，我们还应该对每个元素的LI进行缓存，确保每个元素只计算一次。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span><span class="params">(self, matrix)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type matrix: List[List[int]]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="comment">#参数检查</span></div><div class="line">        <span class="keyword">if</span> matrix <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        matrixSize = len(matrix)</div><div class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line"></div><div class="line">        <span class="comment">#初始化存放increasingPaths的数组</span></div><div class="line">        increasingPaths = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[i]))] <span class="keyword">for</span> i <span class="keyword">in</span> range(matrixSize)]</div><div class="line"></div><div class="line">        <span class="comment">#对每一个元素计算increasingPath</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, matrixSize):</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(matrix[i])):</div><div class="line">                self.calculateIncreasingPath(matrix, i, j, increasingPaths)</div><div class="line"></div><div class="line">        <span class="comment">#选出最大的increasingPath并返回</span></div><div class="line">        <span class="keyword">return</span> max([max(x) <span class="keyword">for</span> x <span class="keyword">in</span> increasingPaths])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateIncreasingPath</span><span class="params">(self, matrix, i, j, increasingPaths)</span>:</span></div><div class="line">        <span class="comment">#如果已经计算过，则直接返回缓存的值</span></div><div class="line">        <span class="keyword">if</span> increasingPaths[i][j] != <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> increasingPaths[i][j]</div><div class="line"></div><div class="line">        nodeValue = matrix[i][j]</div><div class="line"></div><div class="line">        <span class="comment">#计算上方相邻元素</span></div><div class="line">        upPathLen = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> matrix[i - <span class="number">1</span>][j] &gt; nodeValue:</div><div class="line">            upPathLen = self.calculateIncreasingPath(matrix, i - <span class="number">1</span>, j, increasingPaths)</div><div class="line"></div><div class="line">        <span class="comment">#计算左边相邻元素</span></div><div class="line">        leftPathLen = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> matrix[i][j - <span class="number">1</span>] &gt; nodeValue:</div><div class="line">            leftPathLen = self.calculateIncreasingPath(matrix, i, j - <span class="number">1</span>, increasingPaths)</div><div class="line"></div><div class="line">        <span class="comment">#计算下面相邻元素</span></div><div class="line">        downPathLen = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> i &lt; len(matrix) - <span class="number">1</span> <span class="keyword">and</span> matrix[i + <span class="number">1</span>][j] &gt; nodeValue:</div><div class="line">            downPathLen = self.calculateIncreasingPath(matrix, i + <span class="number">1</span>, j, increasingPaths)</div><div class="line"></div><div class="line">        <span class="comment">#计算右边相邻元素</span></div><div class="line">        rightPathLen = <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> j &lt; len(matrix[i]) <span class="number">-1</span> <span class="keyword">and</span> matrix[i][j + <span class="number">1</span>] &gt; nodeValue:</div><div class="line">            rightPathLen = self.calculateIncreasingPath(matrix, i, j + <span class="number">1</span>, increasingPaths)</div><div class="line"></div><div class="line">        <span class="comment">#找出相邻元素中最大的increasingPath，加上1作为当前元素的increasingPath</span></div><div class="line">        increasingPath = max([upPathLen, leftPathLen, downPathLen, rightPathLen]) + <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="comment">#缓存计算结果</span></div><div class="line">        increasingPaths[i][j] = increasingPath</div><div class="line"></div><div class="line">        <span class="keyword">return</span> increasingPath</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://www.scratbai.com/2016/07/04/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
